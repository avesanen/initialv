// Generated by CoffeeScript 1.6.2
/*
# Game Map controller.
#
# Usage:
# var map = require('./gamemap');
# map.init('#mapcanvas');
# map.loadMap('img/map.png');
*/


(function() {
  define(["jquery", "exports"], function($, exports) {
    var canvas, ctx, height, that, width;
    canvas = void 0;
    ctx = void 0;
    width = 2000;
    height = 2000;
    this.gravityConstant = 0.2;
    that = this;
    /*
    # Initialize canvas with the given ID.
    # @param canvasid ID of the canvas to init.
    */

    exports.init = function(canvasid) {
      that.canvas = $(canvasid)[0];
      return that.ctx = that.canvas.getContext("2d");
    };
    /*
    # Load map from given URL
    # @param data map specification JSON
    */

    exports.loadMap = function(data) {
      var docks, i, img, maskdiv, _i, _ref, _results;
      if (data.hasOwnProperty("mapImage")) {
        img = new Image();
        img.onload = function() {
          that.ctx.drawImage(img, 0, 0);
          that.width = img.width;
          return that.height = img.height;
        };
        img.src = data["mapImage"];
      }
      if (data.hasOwnProperty("mapWidth")) {
        that.width = data["mapWidth"];
      }
      if (data.hasOwnProperty("mapHeight")) {
        that.height = data["mapHeight"];
      }
      if (data.hasOwnProperty("maskdiv")) {
        maskdiv = $("#maskdiv")[0];
        maskdiv.style.background = "url(\"" + val + "\")";
      }
      if (data.hasOwnProperty("docks")) {
        docks = data["docks"];
        _results = [];
        for (i = _i = 0, _ref = docks.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(docks.hasOwnProperty(i));
        }
        return _results;
      }
    };
    /*
    # Draw a horizontal line directly to canvas image data
    # The line is completely black and transparent
    # @param x1
    # @param x2
    # @param y
    */

    exports.drawLine = function(x1, x2, y) {
      var imgd, j;
      width = x2 - x1;
      if (width > 0) {
        imgd = that.ctx.createImageData(width, 1);
        j = 0;
        while (j < width * 4) {
          imgd.data[j] = 0;
          j++;
        }
        return that.ctx.putImageData(imgd, x1, y);
      }
    };
    /*
    # Create a crater to the map
    # @param center_x
    # @param center_y
    # @param r radius
    */

    exports.createCrater = function(center_x, center_y, r) {
      var x, y, _results;
      x = 0;
      y = r;
      _results = [];
      while (x <= y) {
        exports.drawLine(center_x - x, center_x + x, center_y + y);
        exports.drawLine(center_x - x, center_x + x, center_y - y);
        exports.drawLine(center_x - y, center_x + y, center_y + x);
        exports.drawLine(center_x - y, center_x + y, center_y - x);
        x++;
        if (Math.abs(x * x + y * y - r * r) > Math.abs(x * x + (y - 1) * (y - 1) - r * r)) {
          _results.push(y--);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    /*
    # Get collision value from the map canvas at specific coords.
    # Used for bullet/ship <-> map collision detection.
    # @param x
    # @param y
    # @returns true or false
    */

    exports.getMapCollision = function(x, y) {
      var pixel;
      if (x < 0 || y < 0 || x > that.canvas.width || y > that.canvas.height) {
        return true;
      }
      pixel = that.ctx.getImageData(x, y, 1, 1);
      if ((pixel.data[3] > 0) && ((pixel.data[2] > 0) || (pixel.data[1] > 0) || (pixel.data[0] > 0))) {
        return true;
      } else {
        return false;
      }
    };
  });

}).call(this);
